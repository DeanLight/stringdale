# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/006_diagram_base.ipynb.

# %% auto 0
__all__ = ['logger', 'validate_logger', 'BaseModelExtra', 'get_attr_metadata', 'get_state_key', 'set_state_key', 'DiagramType',
           'DiagramSchema', 'Diagram', 'NodeMapper', 'diagram_to_dot', 'get_recursive_diagrams', 'draw_diagram',
           'compress_cuts']

# %% ../nbs/006_diagram_base.ipynb 5
import os
import sys
import enum
from pathlib import Path
from copy import deepcopy
import itertools
import functools
from enum import Enum
from parse import parse
from typing import Any
from copy import deepcopy,copy


from collections import defaultdict,OrderedDict
from contextlib import ExitStack
from singleton_decorator import singleton

from pprint import pprint
from pydantic import BaseModel
from pydantic_core import SchemaValidator

from typing import Optional,Union,List,Dict,Any,Literal,Callable

import networkx as nx
from networkx.readwrite import json_graph
from fastcore.basics import patch
from tqdm.auto import tqdm
import logging


# %% ../nbs/006_diagram_base.ipynb 6
logger = logging.getLogger(__name__)

# %% ../nbs/006_diagram_base.ipynb 7
from IPython.display import display,Image,Markdown


# %% ../nbs/006_diagram_base.ipynb 8
from pydantic import BaseModel, ConfigDict
from .core import jinja_render,checkLogs,maybe_await,_duplicates,wrap_exception,NamedLambda
from .viz import draw_nx,draw_graphviz,display_in_ipython
from stringdale.mappings import (
    parse_edge_descriptor,
    multi_map,
    assert_keys_contiguous,
    access_object,
    map_object,
    object_to_args_kwargs,
)

import inspect
from textwrap import dedent
from parse import parse
import re
import itertools as it
import types
import uuid
import time
import json

# %% ../nbs/006_diagram_base.ipynb 10
from pydantic import BaseModel,ConfigDict,computed_field
from typing import Annotated

# %% ../nbs/006_diagram_base.ipynb 11
class BaseModelExtra(BaseModel):
    model_config = ConfigDict(extra='allow')


# %% ../nbs/006_diagram_base.ipynb 12
def _is_attr_method(obj,attr):
    if not hasattr(obj,attr):
        return False
    attr_value = getattr(obj,attr)
    return inspect.ismethod(attr_value)

def get_attr_metadata(obj,attr):
    type_fields = obj.model_fields
    if not attr in type_fields:
        return False
    field_info = type_fields[attr]
    if not hasattr(field_info,'metadata'):
        return False
    if len(field_info.metadata) == 0:
        return False
    return field_info.metadata[0]

@wrap_exception("When getting state key {{key}} from state {{state}}:")
def get_state_key(state,key):
    is_key_method = _is_attr_method(state,key)
    if is_key_method:
        return getattr(state,key)()
    else:
        return getattr(state,key)

@wrap_exception("When setting state key {{key}} to {{value}} in state {{state}}:")
def set_state_key(state,key,value):
    is_key_method = _is_attr_method(state,key)
    attr_metadata_func = get_attr_metadata(state,key)
    if is_key_method:
        getattr(state,key)(value)
    elif attr_metadata_func:
        key_state = get_state_key(state,key)
        attr_metadata_func(key_state,value)
    else:
        setattr(state,key,value)


# %% ../nbs/006_diagram_base.ipynb 20
class DiagramType(Enum):
    flow = 'flow'
    decision = 'decision'

class DiagramSchema:
    def __init__(self,
        graph = None,
        state_class = BaseModelExtra,
        factored_graph = None,
        start_node = None,
        end_node = None,
        name=None,
        type:DiagramType=None,
        anon=False,
        derive_state=False,
        ):
        """A class representing a diagram schema for computational graphs.

        A Diagram defines a directed graph structure where nodes represent computational steps
        and edges represent data flow between them. 
        and supports validation of graph structure and parallel execution paths.

        Params:
            name (str): Optional name for the diagram schema
            graph (nx.DiGraph): The underlying NetworkX directed graph
            factored_graph (nx.DiGraph, optional): A simplified version of the graph after factorisation,
                where the entire diagram is of a single type.
            start_node (str): Name of the starting node, defaults to 'Start'
            end_node (str): Name of the ending node, defaults to 'End'
            type (DiagramType): The type of diagram (e.g. Flow, Decision)
            anon (bool): Whether this is an anonymous diagram
            derive_state (bool): Whether to derive the state from a calling diagram
            
        """
        self.name = name
        self.graph = graph or nx.DiGraph()
        self.factored_graph = factored_graph
        self.start_node = start_node or 'Start'
        self.end_node = end_node or 'End'
        self.type = type
        self.anon = anon
        self.derive_state = derive_state
        self.state_class = state_class
        self.funcs = dict()

    def __str__(self):
        return f'Diagram({self.name})'

    def __contains__(self,node):
        return node in self.graph.nodes    

    def __getitem__(self,node):
        return self.funcs.get(node,None)

    def __setitem__(self,node,value=None):
        self.funcs[node] = value

    def has_breakpoints(self):
        """Check if diagram contains any breakpoints.
        Returns True if any node has is_break=True or contains a subdiagram with breakpoints.
        """
        graph = self.factored_graph
        for node, data in graph.nodes(data=True):
            # Check if current node is a breakpoint
            if data.get('is_break', False):
                return True
                
            # Check if node contains a subdiagram with breakpoints
            func = self[node]
            if isinstance(func, DiagramSchema) and func.has_breakpoints():
                return True
                
        return False

    @functools.cached_property
    def read_keys(self):
        read_keys = set()
        for node, data in self.graph.nodes(data=True):
            func = self[node]
            if isinstance(func, DiagramSchema):
                read_keys.update(func.read_keys)
        return read_keys

    @functools.cached_property
    def write_keys(self):
        write_keys = set()
        for node, data in self.graph.nodes(data=True):
            func = self[node]
            if isinstance(func, DiagramSchema):
                write_keys.update(func.write_keys)
        return write_keys

# %% ../nbs/006_diagram_base.ipynb 21
class Diagram():
    """
    An instance of a stringdale diagram. Instantiated by calling the Schema()

    Has the following public attributes:
    output - the output of the last run
    finished - whether the diagram has reached the End node
    state - the current state of the diagram

    """

    def __init__(self,graph,funcs,type,schema:DiagramSchema,state:BaseModel=None,anon=False,root=None):
        self.graph = graph
        self.funcs = funcs
        self.type = type
        self.state = state
        self.schema = schema
        self.anon = anon
        self.root = root
        self.schema_nodes = list(schema.graph.nodes)
        self.name = schema.name
        self.start_node = schema.start_node
        self.end_node = schema.end_node
        
    def reset(self):
        self.state = None
        self.finished=None
        self.output = None
        self.run_uid = str(uuid.uuid4())

        
        for node in self.graph.nodes:
            if not node in self:
                continue
            func = self[node]
            if isinstance(func,DiagramSchema):
                raise ValueError(f"DiagramSchema nodes are not allowed in a Diagram, they must be instantiated before being added to a Diagram")
            if _is_attr_method(func,'reset'):
                func.reset()

    def get_root(self):
        if self.anon:
            return self.root
        else:
            return self

    def __getitem__(self,key):
        return self.get_root().funcs.get(key,None)  

    def __setitem__(self,key,value):
        self.get_root().funcs[key] = value

    def __contains__(self,key):
        return key in self.get_root().funcs

    def __str__(self):
        return f'Diagram({self.name})@{hex(id(self))}'

    @property
    def attrs_to_serialize(self):
        return ['output','finished','next_node','run_uid']

    def draw(self,
        return_dot=False,
        direction='LR',
        recursive: Union[bool,List[str]]=False,
        factored=False,
        **kwargs
        ):
        return draw_diagram(self.schema,funcs=self.funcs,
            return_dot=return_dot,direction=direction,
            recursive=recursive,factored=factored,**kwargs)  
        

# %% ../nbs/006_diagram_base.ipynb 22
@patch
def __call__(self:DiagramSchema,**kwargs):
    
    # make a copy of the graph
    graph = self.graph.copy()
    # and funcs
    funcs = self.funcs.copy()
    funcs = funcs | kwargs
    # reset stateful functions
    for node,func in funcs.items():
        if _is_attr_method(func,'reset'):
            funcs[node] = deepcopy(func)
            funcs[node].reset()

    instance = Diagram(graph=self.factored_graph,funcs=funcs,type=self.type,schema=self)

    for node,func in list(funcs.items()):
        if isinstance(func,DiagramSchema):
            is_schema_anon = func.anon
            func = func()
            func.anon = is_schema_anon
            func.root = instance
            instance.funcs[node] = func
    
    # init running state
    instance.reset()
    return instance 

# %% ../nbs/006_diagram_base.ipynb 23
@patch
def get_input_only_state_keys(self:DiagramSchema):
    nodes = self.graph.nodes
    input_state_keys = set()
    output_state_keys = set()
    for node in nodes:
        for key,port in nodes[node].get('read_state',{}).items():
            input_state_keys.add(key)
        for key,port in nodes[node].get('write_state',{}).items():
            output_state_keys.add(key)

    input_only_state_keys = input_state_keys - output_state_keys
    return input_only_state_keys


# %% ../nbs/006_diagram_base.ipynb 27
from textwrap import indent
import re

# %% ../nbs/006_diagram_base.ipynb 28
import ast
import inspect
import re

def _get_lambda_source(lambda_func):
    try:
        # Get the complete source lines containing the lambda
        source = inspect.getsource(lambda_func)
        
        # Find the lambda definition using regex
        lambda_match = re.search(r'(lambda\s+[^:]+:[^,\n\]})]+)', source)
        if lambda_match:
            lambda_str = lambda_match.group(1)
            
            # Validate and clean the lambda string using ast
            try:
                ast.parse(lambda_str)
                # Strip 'lambda' and whitespace around parameters
                lambda_str = re.sub(r'lambda\s+', '', lambda_str)
                return lambda_str
            except SyntaxError:
                pass
                
    except Exception:
        pass
    
    return 'Unparseable lambda'

# %% ../nbs/006_diagram_base.ipynb 29
def _get_func_name(func):
    if isinstance(func,(types.FunctionType,types.MethodType)):
        if func.__name__ == '<lambda>':
            return _get_lambda_source(func)
        if hasattr(func,'__qualname__'):
            return func.__qualname__
        if hasattr(func,'__name__'):
            return func.__name__
    else:
        return str(func)

def _get_step_name(node_name,data,func=None):
    description_parts = []
    if func is not None:
        description_parts.append(_get_func_name(func))
    if 'for_each' in data:
        description_parts.append(f'foreach=[{", ".join(map(str,data["for_each"]))}]')
    if 'filter' in data:
        description_parts.append('filter=True')
    if 'flat' in data:
        description_parts.append('flat=True')

    description = ', '.join(description_parts)
    if len(description) > 0:
        description = f'[ {description} ]'
    return f'{node_name}{description}'


def _accessor_to_string(accessor):
    if accessor is None:
        return ''
    return f'.'.join([str(acc) for acc in accessor])

def _mapping_to_string(mapping):
    if mapping == {0:('.',)}:
        return ''
    return ', '.join([f'{_accessor_to_string(v)} -> {k}' for k,v in mapping.items()])

def _condition_to_string(condition):
    if condition is None:
        return ''
    return f'?({_get_func_name(condition)})'

def _get_edge_string(u,v,data,mapping):
    condition = data.get('condition',None)
    mapping_string = _mapping_to_string(mapping)
    condition_string = _condition_to_string(condition)

    if len(mapping_string)> 0 and len(condition_string) > 0:
        condition_string += ': '

    if len(mapping_string) == 0 and len(condition_string) == 0:
        return None

    return f'{condition_string}{mapping_string}'




# %% ../nbs/006_diagram_base.ipynb 30
class NodeMapper():
    def __init__(self):
        self.counter = itertools.count()
        self.item_to_id = {}

    def __getitem__(self,item):
        if item not in self.item_to_id:
            self.item_to_id[item] = f'node_{next(self.counter)}'
        return self.item_to_id[item]    

    def __contains__(self,item):
        return item in self.item_to_id

# %% ../nbs/006_diagram_base.ipynb 31
def _diagram_to_graphviz_data(g,funcs):
    
    node_mapper = NodeMapper()
    node_data_list = []
    edge_data_list = []

    for node,data in g.nodes(data=True):
        node_id = node_mapper[node]
        func = funcs.get(node,None)
        step_description = _get_step_name(node,data,func)
        is_break = data.get('is_break',False)
        is_stream = len(data.get('for_each',[])) > 0

        style = 'solid,filled'
        if is_break:
            style = 'dashed,filled'
        elif is_stream:
            style = 'bold,filled'

        node_data= {
            'name': node_id,
            'label': step_description,
            'shape': 'box',
            'style': style,
        }

        node_data_list.append(node_data)

        for key,mapping in data.get('read_state', {}).items():
            state_edge_name = _mapping_to_string(mapping)

            state_node_name = f'state_{key}'
            new_state = not state_node_name in node_mapper
            state_node_id = node_mapper[state_node_name]
            if new_state:
                node_data_list.append({
                    'name': state_node_id,
                    'label': f'State[{key}]',
                    'shape': 'cylinder',
                    'style': 'solid,filled',
                })
            edge_data_list.append({
                'tail_name': state_node_id,
                'head_name': node_id,
                'label': state_edge_name,
                'style': 'dashed',
            })
                
        
        for key,mapping in data.get('write_state', {}).items():
            state_edge_name = _mapping_to_string(mapping)

            state_node_name = f'state_{key}'
            new_state = not state_node_name in node_mapper
            state_node_id = node_mapper[state_node_name]
            if new_state:
                node_data_list.append({
                    'name': state_node_id,
                    'label': f'State[{key}]',
                    'shape': 'cylinder',
                    'style': 'solid,filled',
                })
            edge_data_list.append({
                'tail_name': node_id,
                'head_name': state_node_id,
                'label': state_edge_name,
                'style': 'dashed',
            })


    for u,v,data in g.edges(data=True):
        edge_mapping = data.get('mapping',{0:('.',)})
        edge_name = _get_edge_string(u,v,data,edge_mapping)
        
        if data['type'] == DiagramType.flow:
            style = 'solid'
            color = 'black'
        else:
            style = 'bold'
            color = 'blue'
        edge_data_list.append({
            'tail_name': node_mapper[u],
            'head_name': node_mapper[v],
            'label': edge_name,
            'style': style,
            'color': color,
        })
    
    return node_data_list,edge_data_list
    

# %% ../nbs/006_diagram_base.ipynb 34
def diagram_to_dot(graph,name,funcs,direction='TB',**kwargs):
    
    node_data_list,edge_data_list = _diagram_to_graphviz_data(graph,funcs=funcs)
    dot = draw_graphviz(node_data_list,edge_data_list,
        name=name,direction=direction,
        node_attrs={'shape':'box','color':'#9370DB','fillcolor':'#ECECFF'}
        ,edge_attrs={},graph_attrs={},**kwargs)
    return dot

def _match_any(name,patterns):
    for pattern in patterns:
        if re.match(pattern,name):
            return True
    return False


# %% ../nbs/006_diagram_base.ipynb 36
def get_recursive_diagrams(diagram,funcs,recursive: Union[bool,List[str]]=False,factored=False):

    if isinstance(diagram,Diagram):
        diagram = diagram.schema
    diagrams_to_draw = [(diagram,funcs)]
    if recursive is True:
        recursive = ['.*']
    elif recursive is False:
        recursive = []

    if factored or recursive:
        for node in diagram.factored_graph.nodes():
            func = funcs.get(node,None)
            if isinstance(func,(DiagramSchema,Diagram)):
                should_draw = _match_any(node,recursive) or (factored and func.anon)
            else:
                continue
            if should_draw:
                sub_d = func
                if sub_d.anon:
                    funcs = funcs
                else:
                    funcs = sub_d.funcs
                diagrams_to_draw.extend(get_recursive_diagrams(sub_d,funcs,recursive,factored))
    return diagrams_to_draw
        

def draw_diagram(diagram,
    return_dot=False,
    direction='LR',
    recursive: Union[bool,List[str]]=False,
    factored=False,
    funcs=None,
    **kwargs
    ):
    """Draw a DiagramSchema using graphviz.
    
    
    Args:
        diagram: Either a diagram object or a diagram scheme object
        name: If provided, uses this name for the diagram in the Mermaid title
        return_dot: If True, returns the graphviz dot object
        direction: direction to draw, either TB (top to bottom) or LR (left to right), defaults to TB
        recursive: Whether to draw subdiagrams as well. 
            If False, only the top level diagram is drawn.
            If True, all subdiagrams are drawn.
            If a list of strings, only the subdiagrams with whose names the regex strings are drawn.
        factored: If True, draws the factored graph, used for debugging
    Returns:
        If return_dot is True, returns dot objects
        Otherwise displays diagram when in an Ipython environment
       
    """

    default_kwargs = {
        'width':20,
        'break_long_words':False,
        'replace_whitespace':False,
    }
    if funcs is None:
        funcs = diagram.funcs
    
    diagrams_to_draw = get_recursive_diagrams(diagram,funcs,recursive,factored)
    # TODO maybe return pairs of diagrams and funcs?
    dot_per_diagram = {}
    for diagram,funcs in diagrams_to_draw:
        if factored:
            dot_per_diagram[diagram.name] = diagram_to_dot(diagram.factored_graph,diagram.name,funcs,direction=direction,**(default_kwargs|kwargs))
        else:
            dot_per_diagram[diagram.name] = diagram_to_dot(diagram.graph,diagram.name,funcs,direction=direction,**(default_kwargs|kwargs))
    
    if return_dot:
        if recursive or factored:
            return dot_per_diagram
        else:
            return list(dot_per_diagram.values())[0]
        
    for name,dot in dot_per_diagram.items():
        display_in_ipython(dot)

@patch
def draw(self:DiagramSchema,
    return_dot=False,
    direction='LR',
    recursive: Union[bool,List[str]]=False,
    factored=False,
    **kwargs
    ):
    """Draw a DiagramSchema using graphviz.
    
    
    Args:
        diagram: Either a diagram object or a diagram scheme object
        name: If provided, uses this name for the diagram in the Mermaid title
        return_dot: If True, returns the graphviz dot object
        direction: direction to draw, either TB (top to bottom) or LR (left to right), defaults to TB
        recursive: Whether to draw subdiagrams as well. 
            If False, only the top level diagram is drawn.
            If True, all subdiagrams are drawn.
            If a list of strings, only the subdiagrams with whose names the regex strings are drawn.
        factored: If True, draws the factored graph, used for debugging
    Returns:
        If return_dot is True, returns dot objects
        Otherwise displays diagram when in an Ipython environment
       
    """
    return draw_diagram(self,return_dot=return_dot,direction=direction,recursive=recursive,factored=factored,**kwargs)
    

# %% ../nbs/006_diagram_base.ipynb 39
def _assert_single_edge_type(graph,node):
    in_edge_types = set(d['type'] for u,v,d in graph.in_edges(node,data=True))
    out_edge_types = set(d['type'] for u,v,d in graph.out_edges(node,data=True))
    if len(in_edge_types) > 1 or len(out_edge_types) > 1:
        raise ValueError(f"Node {node} has multiple edge types: in edge types '{in_edge_types}' and out edge types '{out_edge_types}'")

def _get_edge_type(graph,node,input_edge=False,output_edge=False):
    if input_edge:
        edges_data = [d for u,v,d in graph.in_edges(node,data=True)]
    elif output_edge:
        edges_data = [d for u,v,d in graph.out_edges(node,data=True)]
    if len(edges_data) == 0:
        return None
    return edges_data[0]['type']

def _has_different_edge_type(graph,node,edge_type,input_edge=False,output_edge=False):
    node_edge_type = _get_edge_type(graph,node,input_edge=input_edge,output_edge=output_edge)
    if node_edge_type is None:
        return False
    else:
        return node_edge_type != edge_type


def _subgraph_by_edge_type(graph,edge_type):
    return nx.edge_subgraph(graph,[(u,v) for u,v,d in graph.edges(data=True) if d['type'] == edge_type])

def _get_reachable_nodes(graph,node,reversed=False,bidirectional=False):
    if bidirectional:
        undirected_graph = graph.to_undirected()
        return set(nx.descendants(undirected_graph,node)).union({node})
    if reversed:
        return set(nx.ancestors(graph,node)).union({node})
    else:
        return set(nx.descendants(graph,node)).union({node})


def _replace_subgraph_with_node(g,subgraph,node_name,node_attrs=None):
    if node_attrs is None:
        node_attrs = {}
    g.add_node(node_name,**node_attrs)
    # if there is an edge from a node in subgraph to a node not in subgraph, add an edge from node_name to that node    
    for u,v,d in list(g.edges(data=True)):
        if u in subgraph.nodes() and v not in subgraph.nodes():
            g.add_edge(node_name,v,**d)
        elif v in subgraph.nodes() and u not in subgraph.nodes():
            g.add_edge(u,node_name,**d)
        
        # self edges between nodes in the subgraph that are not part of the subgraph, ie the subgraph is a self loop
        elif u in subgraph.nodes() and v in subgraph.nodes() and (u,v) not in subgraph.edges():
            g.add_edge(node_name,node_name,**d)
    
    # remove all edges in subgraph
    g.remove_nodes_from(list(subgraph.nodes()))
    return g


# %% ../nbs/006_diagram_base.ipynb 40
def compress_cuts(g,funcs,start_node,end_node,ret_raw_graph=False,wrap_as_diagram=False):

    orig_g = g
    g = deepcopy(g)

    logger.debug(f"Compressing graph with nodes {list(g.nodes())}")
    # note that each node can have a single type of input edges and a single type of output edges
    # the current_edge_type is the output type of the start node
    current_edge_type = _get_edge_type(g,start_node,output_edge=True)
    logger.debug(f"Current edge type is {current_edge_type}")
    
    # get the subgraph induced by all nodes of the current edge type, lets call it outer_graph
    outer_graph = _subgraph_by_edge_type(g,current_edge_type)
    logger.debug(f"current cut includes nodes {list(outer_graph.nodes())} and edges {list(outer_graph.edges())}")
    
    # if all edges in graph are in cut return the diagram
    if len(outer_graph.edges()) == len(g.edges()):
        logger.debug("All edges in graph are in cut")
        # we are done ,and we can move to the validation step
        if wrap_as_diagram:
            return DiagramSchema(graph=g,factored_graph=g,start_node=start_node,end_node=end_node,type=current_edge_type,anon=True),current_edge_type,funcs
        else:
            return g,current_edge_type,funcs

    # otherwise, we have a possible nested inner cut
    reachable_from_start = _get_reachable_nodes(outer_graph,start_node)
    reachable_from_end = _get_reachable_nodes(outer_graph,end_node,reversed=True)
    logger.debug(f"Reachable from start {reachable_from_start}")
    logger.debug(f"Reachable from end {reachable_from_end}")

    # sub_cut_entries are all nodes reachable from the start node in cut
    # whose output edge is of a different type in the main graph
    sub_cut_entries = set(node for node in reachable_from_start if _has_different_edge_type(g,node,current_edge_type,output_edge=True))
    logger.debug(f"Sub cut entries are {sub_cut_entries}")
    # sub_cut_exits are all nodes that are reachable in the inverse dirction from end 
    # and have an input edge of a different type in the main graph
    sub_cut_exits = set(node for node in reachable_from_end if _has_different_edge_type(g,node,current_edge_type,input_edge=True))
    logger.debug(f"Sub cut exits are {sub_cut_exits}")
    
    # current cut nodes, are nodes reachable from both start and end by traversing the Cut, 
    # that are not sub_cut_entries or sub_cut_exits
    
    # all nodes between that are not sub_cut_entries or sub_cut_exits or reachable from start without going through end
    bi_directional_reachable_nodes = (
            _get_reachable_nodes(outer_graph,start_node,bidirectional=True) | 
            _get_reachable_nodes(outer_graph,end_node,bidirectional=True)
            )
    outer_scope_nodes = bi_directional_reachable_nodes - sub_cut_entries - sub_cut_exits
    logger.debug(f"outer scope nodes are {outer_scope_nodes}")
    # now we need to figure out which sub_cut_entries map to sub_cut_exits
    # if they are not the same length, this is an error, but we need to find the nodes that are causing the error

    # the inner graph, is the graph without the current cut nodes, and without the edges from sub_cut_exits to sub_cut_entries
    edges_from_ends_to_starts = {(u,v) for u,v in g.edges() if u in sub_cut_exits and v in sub_cut_entries}
    inner_graph = g.subgraph(g.nodes() - outer_scope_nodes).copy()
    inner_graph.remove_edges_from(edges_from_ends_to_starts)
    logger.debug(f"Inner graph has nodes {list(inner_graph.nodes())} and edges {list(inner_graph.edges())}")
    
    # for our diagram to be well defined, each sub_cut_entry must have a unique sub_cut_exit reachable from it in the inner graph
    # for each sub_cut_entry, we compute it's reachable nodes in the inner graph, filter them to include only the sub_cut_exits
    exits_per_entry ={
        entry:set(nx.descendants(inner_graph,entry)) & sub_cut_exits
        for entry in sub_cut_entries
    }
    logger.debug(f"Exits per entry {exits_per_entry}")

    
    # if there are any sub_cut_entries that have no sub_cut_exits or more than one, we collect all of them and raise an error message

    entries_with_wrong_number_of_exits = set()
    for entry,exists in exits_per_entry.items():
        if len(exists) == 0 or len(exists) > 1:
            entries_with_wrong_number_of_exits.add(entry)
    if len(entries_with_wrong_number_of_exits) > 0:
        wrong_entries_dict = {entry:exists for entry,exists in exits_per_entry.items() if entry in entries_with_wrong_number_of_exits}
        raise ValueError(
            f"Trying to compress diagram with nodes {list(g.nodes())}, whose main type is {current_edge_type}",
            f"found the following nodes that are defined within a nested scope {list(inner_graph.nodes())}",
            f"The following entries have no exits or more than one exit: {wrong_entries_dict}"
            )

    
    # now, if we are here, we have a list of sub_cut_entries and sub_cut_exits pairs.
    # they should be disjoint, meaning no node should be reachable from 2 starts or from 2 ends

    entry_exit_pairs = [
        (entry,list(exits)[0]) for entry,exits in exits_per_entry.items()
    ]
    logger.debug(f"Entry exit pairs {entry_exit_pairs}")

    # for each such pair,
    sub_diagrams = []
    sub_graphs = []
    for entry,exit in entry_exit_pairs:
        # their induced subdiagram is the inner graph induced on all nodes reachable from the entry node

        sub_graph = inner_graph.subgraph(nx.descendants(inner_graph,entry) | {entry})
        sub_graphs.append(sub_graph)
        logger.debug(f"Processing subcut with start node '{entry}' and end node '{exit}'\n"
                     f"Sub graph has nodes {list(sub_graph.nodes())} and edges {list(sub_graph.edges())}"
                     f"Calling compress_cuts on it"
                     )
        #  make a recursive call to compress_cuts on the induced subdiagram
        sub_diagram,_,_ = compress_cuts(sub_graph,funcs,entry,exit,ret_raw_graph=ret_raw_graph,wrap_as_diagram=True)
        sub_diagrams.append(sub_diagram)
    
        
    # assuming the recursive calls succeeded, 
    # compress the graph by replacing each sub_graph with a node that has the sub_diagram as its function
    for sub_graph,sub_diagram,(entry,exit) in zip(sub_graphs,sub_diagrams,entry_exit_pairs):
        sub_diagram.anon = True
        logger.debug(f"Replacing sub graph {list(sub_graph.nodes())} with node {f'{entry}->{exit}_diagram'}")

        sub_diagram.name = f'anon_from_{entry}_to_{exit}'
        g=_replace_subgraph_with_node(g,sub_graph,sub_diagram.name)

        funcs[sub_diagram.name] = sub_diagram
        logger.debug(f"After replacement, graph has nodes {list(g.nodes())} and edges {list(g.edges())}")

    # return the compressed graph as a diagram of the current edge type
    if wrap_as_diagram:
        ret_val = DiagramSchema(orig_g,factored_graph=g,start_node=start_node,end_node=end_node,type=current_edge_type,anon=True)
    else:
        ret_val = g
    return ret_val,current_edge_type,funcs



# %% ../nbs/006_diagram_base.ipynb 41
@patch
def factor_diagram(self:DiagramSchema):
    factored_g,new_type,new_funcs = compress_cuts(self.graph,self.funcs,self.start_node,self.end_node)
    self.factored_graph = factored_g
    self.type = new_type
    self.funcs = new_funcs

    for node,func in new_funcs.items():
        if isinstance(func,DiagramSchema) and func.anon:
            func.root_diagram = self
    return self

# %% ../nbs/006_diagram_base.ipynb 51
validate_logger = logging.getLogger(f'{__name__}.validate')

def _validate_diagram_unfactored(diagram):
    
    g = diagram.graph

    validate_logger.debug(f"Validating unfactored diagram {diagram.name}")

    def get_father_target_ports(father,node):
        edge_data = g.edges[father,node]
        target_ports = edge_data.get('mapping',{}).keys()
        return list(target_ports)


    # make sure all nodes have a single edge type
    for node,data in g.nodes(data=True):
        _assert_single_edge_type(g,node)

    validate_logger.debug(f"All nodes have a single edge type")

    for node in g.nodes():
        
        input_state_ports = list(g.nodes[node].get('read_state',{}).keys())
        input_edge_type = _get_edge_type(g,node,input_edge=True)

        if input_edge_type == DiagramType.decision:
            for father_node,_,edge_data in g.in_edges(node,data=True):
                father_target_ports = list(edge_data.get('mapping',{}).keys())
                # if there is an overlap between the father_target_ports and the input_state_ports, raise an error
                intersection = set(father_target_ports).intersection(input_state_ports) 
                if intersection:
                    raise ValueError(f"Node {node} has the conflicting input ports '{intersection}' \n"
                                    f" in both its state and its father node {father_node}\n"
                                    )
                union = set(father_target_ports).union(input_state_ports)
                if not assert_keys_contiguous(union):
                    raise ValueError(f"Node {node}'s input key are not contiguos (0,1,2,3... without gaps) when coming from:\n"
                                    f"{father_node} and state\n"
                                    f"The input keys are {union}"
                                    )

        elif input_edge_type == DiagramType.flow:
            # for flow inputs we check all incoming nodes together
            port_set_per_father = {
                'input_state_ports':input_state_ports,
            }
            
            for father,_,edge_data in g.in_edges(node,data=True):
                father_target_ports = list(edge_data.get('mapping',{}).keys())
                port_set_per_father[father] = father_target_ports
            
            duplicate_ports = _duplicates(port_set_per_father.values())
            if len(duplicate_ports) > 0:
                raise ValueError(f"Node {node} has conflicting input ports '{duplicate_ports}'\n"
                                 f"between its father nodes and/or state {port_set_per_father}")
            union = set(input_state_ports)
            for father_ports in port_set_per_father.values():
                union = union.union(set(father_ports))
            if not assert_keys_contiguous(union):
                raise ValueError(f"Node {node}'s input key are not contiguos (0,1,2,3... without gaps) when coming from:\n"
                                f"{port_set_per_father}\n"
                                f"The input keys are {union}"
                                )


    start_node = diagram.start_node
    end_node = diagram.end_node

    if not nx.has_path(g,start_node,end_node):
        raise ValueError(f"Diagram {diagram.name} has no path from start node {start_node} to end node {end_node}")

    no_input_nodes = {node for node in g.nodes() if len(g.in_edges(node)) == 0}
    if no_input_nodes!={start_node}:
        extra_nodes = no_input_nodes-{start_node}
        raise ValueError(f"Diagram {diagram.name} has unreachable nodes with no input edges except for the start node({start_node}): {extra_nodes}")





# %% ../nbs/006_diagram_base.ipynb 53
def _validate_diagram_factored(diagram):
    graph = diagram.factored_graph
    
    # we keep for each node in the unfactored graph, the nested node in the factored graph
    # it corresponds to.
    nodes_to_nested_nodes = {node:[node] for node in graph.nodes}

    # validate all anonymous subdiagrams recursively
    anon_sub_diagrams = []
    for node,node_data in graph.nodes(data=True):
        func = diagram[node]
        if isinstance(func,DiagramSchema) and func.anon:
            sub_diag_nested_nodes = _validate_diagram_factored(func)

    match diagram.type:
        case DiagramType.flow:
            _validate_flow_diagram(diagram)
        case DiagramType.decision:
            _validate_decision_diagram(diagram)


    # for each node, compute its port mappings dict of the form {'father_node':mapping_dict}
    for node,node_data in graph.nodes(data=True):
        port_mappings = {}
        # regular father mappings
        for father,_,edge_data in graph.in_edges(node,data=True):
            port_mappings[father] = edge_data.get('mapping',{})
        # read state mappings
        for key,mapping in node_data.get('read_state',{}).items():
            port_mappings[('state',key)] = mapping
        node_data['mapping'] = port_mappings
        validate_logger.debug(f"Port mapping for node {node}:{dict(port_mappings)}")



def _validate_flow_diagram(diagram):
    graph = diagram.factored_graph
    if diagram.has_breakpoints():  
        raise ValueError(f"Breakpoints are not allowed in a Flow diagram ({diagram.name})")

    if len(diagram.write_keys) > 0:
        raise ValueError(f"Flow diagrams cannot have write keys, but diagram {diagram.name} has write keys {diagram.write_keys}")

    # make sure that ends of flow diagrams are not mapped, meaning they collect all their inputs
    if graph.nodes[diagram.end_node].get('for_each',list()) != []:
        raise ValueError(f"End node {diagram.end_node} of flow diagram {diagram.name} is cannot have for_each inputs.\n"
                        f"The end of the flow diagram must be a single node that collects all its inputs into a single output")


    # for each node we compute the for_each_fathers. The fathers that have foreach ports
    for node,node_data in graph.nodes(data=True):
        for_each_ports = node_data.get('for_each',list())
        for_each_fathers = set()
        regular_fathers = set()
        for father,_,edge_data in graph.in_edges(node,data=True):
            target_port = edge_data.get('target_port',None)
            if isinstance(target_port,tuple):
                for port in target_port:
                    if port in for_each_ports:
                        for_each_fathers.add(father)
                    else:
                        regular_fathers.add(father)
            else:
                if target_port in for_each_ports:
                    for_each_fathers.add(father)
                else:
                    regular_fathers.add(father)
        node_data['regular_fathers'] = regular_fathers
        node_data['for_each_fathers'] = for_each_fathers


    

def _validate_decision_diagram(diagram):
   
    graph = diagram.factored_graph


    for node,data in graph.nodes(data=True):
        out_edges = list(graph.out_edges(node,data=True))
        edges_without_condition = [ (s,t,d) for s,t,d in out_edges if d.get('condition',None) is None]
        if len(edges_without_condition) > 1:
            clean_edges = [(s,t) for s,t,d, in edges_without_condition]
            raise ValueError(f"In a Decision diagram, Node {node} cannot have multiple output edges with no condition\n"
                            f"Currenlty, edges {clean_edges} do not have a condition.\n")
        
        if node == diagram.end_node:
            continue
        # check that all nodes except the End node have an output edge.
        if len(list(graph.out_edges(node,data=False))) == 0:
            raise ValueError(f"Node {node} must have an output edge, since it is not the end node.\n"
                            f"In diagram {diagram.name}"
            )



# %% ../nbs/006_diagram_base.ipynb 55
@patch
def post_def(self:DiagramSchema):
    '''
    validate the graph and factor it
    '''
    logger.debug(f"Post def for diagram {self.name}")
    _validate_diagram_unfactored(self)
    self.factor_diagram()
    _validate_diagram_factored(self)
    

