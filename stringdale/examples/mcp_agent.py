# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/docs/examples/009_mcp_agent.ipynb.

# %% auto 0
__all__ = ['tool_selector', 'execute_tool', 'has_tool_calls', 'MCP_Chat_factory']

# %% ../../nbs/docs/examples/009_mcp_agent.ipynb 4
from typing import Optional, List, Dict, Any
from pydantic import BaseModel, Field
from .. import Define, V, E, Condition, Scope
from ..chat import Chat
import os

from fastmcp import Client
import asyncio


# %% ../../nbs/docs/examples/009_mcp_agent.ipynb 11
# Chat node for tool selection with MCP tools
# This chat will be used in the diagram to select tools
tool_selector = Chat(
    model="gpt-4o-mini",
    mcp_tools=mcp_tools,
)


# %% ../../nbs/docs/examples/009_mcp_agent.ipynb 15
async def execute_tool(tool):
    """
    Extracts the tool name and arguments from the first tool_call in the LLM response,
    executes the tool via mcp_client, and returns the tool response text.
    """
    tool_name = tool['name']
    tool_args = tool['input']  # Already a dict
    async with mcp_client:
        tool_response = await mcp_client.call_tool(tool_name, tool_args)
        tool_response_text = tool_response.content[0].text
    return tool_response_text


# %% ../../nbs/docs/examples/009_mcp_agent.ipynb 17
# Condition to check if tools were selected
#we would do for each in a diagram
# Condition if use tools otherwise end
def has_tool_calls(llm_response):
    # for now don't check anything
    if llm_response is not None:
        return True
    return True



# %% ../../nbs/docs/examples/009_mcp_agent.ipynb 18
def MCP_Chat_factory(mcp_tool_selector_chat,execute_mcp_tool):
    # Factory that returns the MCP Agent diagram definition
    with Define('MCP Agent', type='decision') as MCP_Chat:
        # Start: User query comes in
        # Select tool: Chat with MCP tools to decide which tool to use
        V('select_tool', mcp_tool_selector_chat,
          inputs=['Start(messages=.)'],
          outputs=[
              ('End(role=role,content=content)'),
              ('Start_flow(tools=content.tool_calls)', Condition(has_tool_calls, '(0=content.tool_calls)'))
          ])
        E('Start->State/messages')
        # Execute the selected tool
        V('Start_flow',
        )
        with Scope('flow'):
            V('execute_tool', execute_mcp_tool,
              inputs=['Start_flow(tool = tools)'],
              outputs=['End_flow'],
              for_each=['tool']
            )
            # Format the final answer for the user
        V('End_flow',
          outputs=['End(messages = .)'])
    return MCP_Chat

# %% ../../nbs/docs/examples/009_mcp_agent.ipynb 24
# TODO: do we: 
#   1) save_history attribute through Chat constructor of the select_tool and forward new queries (or even messages - probably easier for unified format)
#   2) maintain history state and always load it as input to select_tool
with Define('MCP Agent', type='decision') as MCPAgent:

    V('select_tool', mcp_tool_selector,
      inputs=['Start(user_query=.)'],
      outputs=[
          ('End'),
          ('Start_flow(tools=content.tool_calls)', Condition(has_tool_calls,'(0=content.tool_calls)'))
      ])
    E('Start->State/user_query')
    # Execute the selected tool
    V('Start_flow',
    )
    with Scope('flow'):
      V('execute_tool', execute_tool,
      inputs=['Start_flow(tool = tools)'],
      outputs=['End_flow(tool_result=.)'],
      for_each=['tool']
      )
    V('End_flow',format_tools_results,
      inputs=[
          #'execute_tool(tool_result=.)',
          'State/user_query(user_query=.)'  # Pass original query from Start
      ],
      outputs=['select_tool'])

    
