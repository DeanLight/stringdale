# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/017_eval.ipynb.

# %% auto 0
__all__ = ['T', 'PartialOrder', 'parse_expected_trace_step', 'parse_expected_trace', 'regex', 'compute_trace_distance',
           'compute_distances']

# %% ../nbs/017_eval.ipynb 11
from typing import TypeVar, Set, List, Optional
from collections import defaultdict

# %% ../nbs/017_eval.ipynb 12
T = TypeVar('T')

class PartialOrder:
    def __init__(self):
        # Store the direct less-than relations
        self.direct_less_than: dict[T, set[T]] = defaultdict(set)
        # Store the transitive closure of less-than relations
        self.less_than: dict[T, set[T]] = defaultdict(set)
        
    def add_relation(self, smaller: T, larger: T) -> None:
        """Add a relation where 'smaller' is less than 'larger'"""
        # Add direct relation
        self.direct_less_than[smaller].add(larger)
        
        # Update transitive closure
        # 1. Add direct relation
        self.less_than[smaller].add(larger)
        
        # 2. Add all relations where 'smaller' is less than something that's less than 'larger'
        for x in self.less_than[larger]:
            self.less_than[smaller].add(x)
            
        # 3. Add all relations where something less than 'smaller' is less than 'larger'
        for x in self.less_than:
            if smaller in self.less_than[x]:
                self.less_than[x].add(larger)
                for y in self.less_than[larger]:
                    self.less_than[x].add(y)
    
    def get_predecessors(self, element: T) -> Set[T]:
        """Get all elements that are less than the given element"""
        predecessors = set()
        for potential_pred, successors in self.less_than.items():
            if element in successors:
                predecessors.add(potential_pred)
        return predecessors
    
    def get_successors(self, element: T) -> Set[T]:
        """Get all elements that are greater than the given element"""
        return self.less_than[element]
    
    def get_minimal_elements(self, elements: Set[T]) -> Set[T]:
        """Get all minimal elements from the given set according to the partial order.
        A minimal element has no other elements in the set that are less than it."""
        minimal = set(elements)
        for element in elements:
            # Remove any element that has a predecessor in the set
            predecessors = self.get_predecessors(element)
            if predecessors & elements:  # if there's any overlap with our set
                minimal.remove(element)
        return minimal
    
    def get_maximal_elements(self, elements: Set[T]) -> Set[T]:
        """Get all maximal elements from the given set according to the partial order.
        A maximal element has no other elements in the set that are greater than it."""
        maximal = set(elements)
        for element in elements:
            # Remove any element that has a successor in the set
            successors = self.get_successors(element)
            if successors & elements:  # if there's any overlap with our set
                maximal.remove(element)
        return maximal

# %% ../nbs/017_eval.ipynb 22
def parse_expected_trace_step(yaml_obj: Dict[str,Any],idx:int,labels:List[str]) -> ExpectedTraceStep:
    if len(yaml_obj.keys()) != 1:
        raise SyntaxError(f"Expected a single key in trace step {idx}, got {yaml_obj.keys()}")
    
    name = list(yaml_obj.keys())[0]
    value = yaml_obj[name]
    label = value.pop("$label",None)
    if label is None:
        label = str(idx)

    before = value.pop("$before",list())
    if isinstance(before,str):
        before = [before]
    after = value.pop("$after",list())
    if isinstance(after,str):
        after = [after]
    parallel = value.pop("$parallel",False)

    if parallel and idx == 0:
        raise ValueError(f"Expected trace step {idx} is has $parallel: true, but is the first step")

    if not parallel and len(after) == 0 and idx > 0:
        after.append(labels[-1])
    
    conditions = []
    for accessor,params in value.items():
        if isinstance(params,str):
            params = {"value":params}
        try:
            accessor = parse_edge_descriptor(accessor,start='accessor')
        except Exception as e:
            raise SyntaxError(f"Error parsing accessor {accessor} for step {idx}. Make sure it is formatted correctly") from e
        condition_data ={
            'accessor':accessor,
            **params
        }
        try:
            conditions.append(Condition.model_validate(condition_data))
        except Exception as e:
            raise SyntaxError(f"When parsing condition {value} for step {idx}") from e
    
    return ExpectedTraceStep(name=name,label=label,conditions=conditions,before=before,after=after)
        
    

# %% ../nbs/017_eval.ipynb 26
def parse_expected_trace(yaml_str: str) -> ExpectedTrace:
    if isinstance(yaml_str,Path):
        yaml_string = yaml_str.read_text()
    else:
        yaml_string = yaml_str
    
    try:
        yaml_obj = yaml.safe_load(yaml_string)
    except Exception as e:
        raise SyntaxError(f"Error parsing yaml:\n{yaml_string}\n{e}")

    if list(yaml_obj.keys()) != ["input","expected"]:
        raise SyntaxError(f"Expected keys in main scope are 'input' and 'expected', got {yaml_obj.keys()}")

    input = yaml_obj["input"]
    expected = yaml_obj["expected"]

    parsed_steps = []
    labels = []
    for i,expected_step in enumerate(expected):
        try:
            step = parse_expected_trace_step(expected_step,i,labels)
            parsed_steps.append(step)
            labels.append(step.label)
        except Exception as e:
            raise SyntaxError(f"Error parsing expected trace step:\n{expected_step}") from e
    return ExpectedTrace(input=input,expected=parsed_steps)



# %% ../nbs/017_eval.ipynb 33
def regex(out: str, expected: str,**kwargs) -> float:
    """
    Compare a string against a regex pattern.
    Returns 0 if the regex matches, 1 if it doesn't.
    
    Args:
        out (str): The string to check
        expected (str): The regex pattern to match against
        
    Returns:
        float: 0 if match, 1 if no match
    """
    if not isinstance(out,str) or not isinstance(expected,str):
        return np.inf
    try:
        if re.search(expected, out,flags=re.IGNORECASE) is not None:
            return 0.0
        return 1.0
    except Exception:
        return 1.0


# %% ../nbs/017_eval.ipynb 38
def compute_trace_distance(trace,expected,comparisons,default_comparison):

    logger.debug(f"Computing distance for trace {trace} and expected {expected}")
    if not re.search(expected.name, trace.name):
        return np.inf
    
    # check if all accessors are in the trace
    for condition in expected.conditions:
        try: 
            sub_object = access_object(trace.output,condition.accessor)
        except Exception as e:
            return np.inf

    distance = 0
    for condition in expected.conditions:
        condition_func = comparisons.get(condition.comparison, default_comparison)
        output_sub_value = access_object(trace.output,condition.accessor)
        try:
            condition_distance = condition_func(output_sub_value, condition.value, **condition.kwargs)
        except Exception as e:
            raise ValueError(f"Error computing distance for condition {condition} on trace {trace.name}: {e}") from e
        distance += condition_distance
    
    return distance


# %% ../nbs/017_eval.ipynb 41
def compute_distances(
    traces_outputs:List[Any],
    expected_trace:ExpectedTrace,
    comparisons:Dict[str,Callable],
    default_comparison:Callable):
    """
    Compute the distance matrix between the traces and the expected traces.

    Args:
        traces_outputs: List[Any], the outputs of the traces
        expected_traces: ExpectedTrace, the expected traces
        comparisons: Dict[str,Callable], the comparisons to use for the distance matrix
        default_comparison: Callable, the default comparison to use for the distance matrix
    """
    expected_steps = expected_trace.expected
    distances = defaultdict(dict)
    
    for (i, trace), (j, expected) in it.product(enumerate(traces_outputs), enumerate(expected_steps)):
        d = compute_trace_distance(trace,expected,comparisons,default_comparison)
        if not d == np.inf:
            distances[expected.label][i] = d

    return dict(distances)
    
