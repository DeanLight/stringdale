# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/027_mcp.ipynb.

# %% auto 0
__all__ = ['init_mcp_session_and_tools']

# %% ../nbs/027_mcp.ipynb 6
import asyncio
import nest_asyncio
import json
import os
from typing import Tuple, List, Dict, Any, Optional
from contextlib import asynccontextmanager,AsyncExitStack
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client
from mcp.client.sse import sse_client 


from anthropic import Anthropic

from openai import AsyncOpenAI

# %% ../nbs/027_mcp.ipynb 14
from fastmcp import Client
from fastmcp.client.transports import StreamableHttpTransport, PythonStdioTransport
from .core import get_git_root
from typing import Tuple, List

async def init_mcp_session_and_tools(config: dict) -> Tuple[Client, List]:
    """Init MCP client & fetch tools via HTTP/SSE or stdio transport (auto-detected from config).
    Explicit transport definition for more complex use cases (custom headers, authorization, etc.)

    Args:
        config: Dict with "url" or "server_script_path" and optional params.

    Returns:
        (client, tools): FastMCP Client & list of tools.
    """
    # Check if this is a multi-server configuration
    if "mcpServers" in config:
        # Multi-server mode: pass config directly to Client
        # FastMCP handles the multi-server setup internally
        client = Client(config)
        
        async with client:
            tools = await client.list_tools()
            return client, tools
    # Auto-detect transport type from config
    if "url" in config:
        # HTTP/SSE transport
        transport = StreamableHttpTransport(
            url=config["url"],
            headers=config.get("headers", {}),
        )
    elif "server_script_path" in config:
        # Stdio transport
        server_script_path = config["server_script_path"]
        # Check if the server_script_path is relative (from the main folder) and join with repo root if needed
        from pathlib import Path
        if not Path(server_script_path).is_absolute():
            server_script_path = get_git_root() / server_script_path
        
        transport = PythonStdioTransport(
            script_path=server_script_path,
            env=config.get("env", None),
        )
    else:
        raise ValueError(
            "Config must contain either 'url' (for HTTP/SSE) or "
            "'server_script_path' (for stdio transport)"
        )
    
    # Initialize the client with the transport
    client = Client(transport=transport)
    
    # Connect and get tools
    # Note: FastMCP Client manages connection lifecycle, so we need to use async context
    # But since we're returning the client, the caller will manage the context
    async with client:
        tools = await client.list_tools()
        # Return client and tools
        # Note: The client needs to stay in async context, so caller should use:
        # async with client: ... or we return it differently
        return client, tools
